# Cursor Rules for Dishola Project

## Package Manager Preference
- **ALWAYS use `pnpm`** for package management commands instead of `npm`.
- Use `pnpm install`, `pnpm run`, `pnpm exec`, etc., for all package management tasks.

## API URL Guidelines (CRITICAL)
- **NEVER hardcode API URLs** like `http://localhost:3001` or `https://api.dishola.com`
- **ALWAYS use `API_BASE_URL`** from `@/lib/constants` when making fetch requests to the Nitro API server
- Import: `import { API_BASE_URL } from "@/lib/constants"`
- Usage: `fetch(`${API_BASE_URL}/api/endpoint`)`
- This ensures proper environment handling (dev: localhost:3001, prod: api.dishola.com)

## Shared Types (CRITICAL)
- **ALWAYS use shared types** from `@dishola/types` for all API interactions
- **NEVER define inline types** for API requests/responses - use the shared schemas
- Import types: `import type { ProfileResponse, UserTastesResponse } from "@dishola/types"`
- Import schemas for validation: `import { ProfileResponseSchema } from "@dishola/types"`
- Use Zod schemas for runtime validation when needed: `ProfileResponseSchema.parse(data)`
- All database table types, API request/response types are defined in `@dishola/types`
- This ensures type consistency between frontend and backend

## Architecture Patterns
- Frontend (`apps/web`) should only call the Nitro backend (`apps/api`)
- Every fetch in the frontend (`apps/web`) should use the API_BASE_URL constant and look like "fetch(`${API_BASE_URL}/api/something`)"
- NO direct external API calls from frontend (Google, Unsplash, etc.) - the apps/web/app/api folder should not be something you ever create. Just use the nitro backend.
- API routes should use `@dishola/supabase/admin` for database access

## Code Style
- **ALWAYS use shared types from `@dishola/types`** - never create duplicate type definitions
- Prefer environment variables over hardcoded values
- Follow existing patterns in the codebase
- Use proper TypeScript types and interfaces from the shared types package
- Use Zod schemas for runtime validation when parsing external data
- **ALWAYS use `next/image` instead of `<img>` tags in the web app for images.** Import with `import Image from "next/image"`. Only use `<img>` if `next/image` cannot be used (e.g., for external URLs that are not allowed by next.config.js).

## Authentication
- Use `useAuth()` hook and `getAuthToken()` for authenticated requests
- Include `Authorization: Bearer ${token}` header for protected endpoints
- Handle auth errors gracefully with user-friendly messages

## Loading States and Error Handling (CRITICAL)
- **ALWAYS show loading states** for any API/fetch interactions (spinners, skeletons, etc.)
- **ALWAYS render errors on screen** if they happen - never let errors go unhandled
- Use proper loading indicators like `<Loader2 className="animate-spin" />` or skeleton components
- Display user-friendly error messages with clear actions users can take
- Never leave users wondering if something is loading or if an error occurred

## Code Comments Policy
- **Do NOT write unnecessary comments** - component names and function names should be descriptive enough
- Only add comments when explaining complex business logic, non-obvious algorithms, or important architectural decisions
- Let the code be self-documenting through clear naming and structure
- Avoid commenting obvious operations or simple variable assignments